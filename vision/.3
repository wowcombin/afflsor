8: Системные процессы и автоматизация
8.1 Автоматическое управление статусами
8.1.1 Жизненный цикл карт
Процесс автоматического истечения срока:
sql
-- Функция запускается ежедневно в 01:00 UTC
CREATE OR REPLACE FUNCTION auto_expire_cards()
RETURNS void AS $$
BEGIN
  -- Обновление статуса просроченных карт
  UPDATE cards 
  SET status = 'expired'
  WHERE status = 'active'
    AND (exp_year < EXTRACT(YEAR FROM CURRENT_DATE)
         OR (exp_year = EXTRACT(YEAR FROM CURRENT_DATE) 
             AND exp_month < EXTRACT(MONTH FROM CURRENT_DATE)));
  
  -- Освобождение назначений
  UPDATE card_assignments
  SET status = 'completed'
  WHERE card_id IN (
    SELECT id FROM cards WHERE status = 'expired'
  ) AND status IN ('assigned', 'in_use');
  
  -- Уведомление менеджеров
  INSERT INTO notifications (user_id, type, title, message)
  SELECT DISTINCT u.id, 'system', 'Карты истекли', 
         'Обнаружены истекшие карты, требуется замена'
  FROM users u WHERE u.role = 'manager';
END;
$$ LANGUAGE plpgsql;
Планировщик через pg_cron:
sql
SELECT cron.schedule('expire-cards', '0 1 * * *', 'SELECT auto_expire_cards()');
8.1.2 Контроль балансов банковских аккаунтов
Автоматическое скрытие/показ карт при изменении баланса:
sql
-- Триггер на изменение баланса
CREATE OR REPLACE FUNCTION handle_balance_change()
RETURNS TRIGGER AS $$
BEGIN
  -- Баланс упал ниже $10
  IF NEW.balance < 10 AND OLD.balance >= 10 THEN
    -- Меняем статус назначений на временно недоступные
    UPDATE card_assignments ca
    SET status = 'temporarily_unavailable'
    FROM cards c
    WHERE c.id = ca.card_id
      AND c.bank_account_id = NEW.id
      AND ca.status = 'assigned';
    
    -- Логирование события
    INSERT INTO audit_log(action, table_name, record_id, new_values)
    VALUES ('AUTO_HIDE_CARDS', 'bank_accounts', NEW.id, 
            jsonb_build_object('balance', NEW.balance, 'cards_hidden', true));
  
  -- Баланс восстановлен
  ELSIF NEW.balance >= 10 AND OLD.balance < 10 THEN
    -- Восстанавливаем доступность карт
    UPDATE card_assignments ca
    SET status = 'assigned'
    FROM cards c
    WHERE c.id = ca.card_id
      AND c.bank_account_id = NEW.id
      AND ca.status = 'temporarily_unavailable';
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
8.1.3 Эскалация выводов по SLA
Автоматическая эскалация при превышении времени ожидания:
sql
CREATE OR REPLACE FUNCTION escalate_pending_withdrawals()
RETURNS void AS $$
DECLARE
  v_withdrawal RECORD;
BEGIN
  -- Выводы в ожидании > 15 минут
  FOR v_withdrawal IN 
    SELECT * FROM work_withdrawals 
    WHERE status = 'waiting' 
      AND created_at < NOW() - INTERVAL '15 minutes'
      AND created_at > NOW() - INTERVAL '1 hour'
  LOOP
    -- Уведомление менеджерам
    INSERT INTO notifications(user_id, type, title, message, priority)
    SELECT id, 'withdrawal', 'Вывод требует внимания', 
           'Вывод #' || v_withdrawal.id || ' ожидает более 15 минут', 'high'
    FROM users WHERE role = 'manager';
  END LOOP;
  
  -- Выводы в ожидании > 1 час - критично
  FOR v_withdrawal IN 
    SELECT * FROM work_withdrawals 
    WHERE status = 'waiting' 
      AND created_at < NOW() - INTERVAL '1 hour'
      AND created_at > NOW() - INTERVAL '4 hours'
  LOOP
    -- Создание критического алерта
    INSERT INTO alerts(type, severity, title, description, status)
    VALUES ('withdrawal_delay', 'critical', 
            'Критическая задержка вывода',
            'Вывод #' || v_withdrawal.id || ' не обработан более часа',
            'open');
  END LOOP;
  
  -- Выводы > 4 часов - автоблокировка
  UPDATE work_withdrawals
  SET status = 'block',
      alarm_message = 'Автоблокировка: превышен SLA 4 часа'
  WHERE status = 'waiting'
    AND created_at < NOW() - INTERVAL '4 hours';
END;
$$ LANGUAGE plpgsql;

-- Запуск каждые 5 минут
SELECT cron.schedule('escalate-withdrawals', '*/5 * * * *', 
                    'SELECT escalate_pending_withdrawals()');
8.2 Автоматические расчеты и отчеты
8.2.1 Ежедневный расчет статистики
Обновление дневной статистики junior'ов:
sql
CREATE OR REPLACE FUNCTION calculate_daily_stats()
RETURNS void AS $$
BEGIN
  -- Создание/обновление записей daily_limits
  INSERT INTO daily_limits (user_id, limit_date, total_deposits, deposit_count)
  SELECT 
    w.junior_id,
    CURRENT_DATE,
    COALESCE(SUM(w.deposit_amount), 0),
    COUNT(*)
  FROM works w
  WHERE w.work_date = CURRENT_DATE
  GROUP BY w.junior_id
  ON CONFLICT (user_id, limit_date) 
  DO UPDATE SET 
    total_deposits = EXCLUDED.total_deposits,
    deposit_count = EXCLUDED.deposit_count;
  
  -- Обновление материализованного представления
  REFRESH MATERIALIZED VIEW CONCURRENTLY junior_monthly_stats;
END;
$$ LANGUAGE plpgsql;

-- Запуск в конце дня
SELECT cron.schedule('daily-stats', '0 23 * * *', 'SELECT calculate_daily_stats()');
8.2.2 Автоматический расчет зарплат
Месячный расчет (запускается 1 числа):
sql
CREATE OR REPLACE FUNCTION auto_calculate_salaries()
RETURNS void AS $$
DECLARE
  v_user RECORD;
  v_profit NUMERIC;
  v_salary NUMERIC;
BEGIN
  -- Для каждого активного junior/tester
  FOR v_user IN 
    SELECT * FROM users 
    WHERE role IN ('junior', 'tester') 
      AND status = 'active'
  LOOP
    -- Расчет профита за прошлый месяц
    SELECT COALESCE(SUM(ww.withdrawal_amount - w.deposit_amount), 0)
    INTO v_profit
    FROM works w
    JOIN work_withdrawals ww ON ww.work_id = w.id
    WHERE w.junior_id = v_user.id
      AND ww.status = 'received'
      AND w.work_date >= date_trunc('month', CURRENT_DATE - INTERVAL '1 month')
      AND w.work_date < date_trunc('month', CURRENT_DATE);
    
    -- Расчет зарплаты
    v_salary := (v_profit * v_user.salary_percentage / 100) + v_user.salary_bonus;
    
    -- Сохранение расчета
    INSERT INTO salary_calculations(
      user_id, month, gross_profit, base_salary, 
      bonus, total_salary
    ) VALUES (
      v_user.id,
      date_trunc('month', CURRENT_DATE - INTERVAL '1 month'),
      v_profit,
      v_profit * v_user.salary_percentage / 100,
      v_user.salary_bonus,
      v_salary
    );
  END LOOP;
  
  -- Уведомление CFO
  INSERT INTO notifications(user_id, type, title, message, priority)
  SELECT id, 'system', 'Расчет зарплат завершен', 
         'Готов к проверке и утверждению', 'high'
  FROM users WHERE role = 'cfo';
END;
$$ LANGUAGE plpgsql;

-- Запуск 1 числа каждого месяца
SELECT cron.schedule('monthly-salaries', '0 2 1 * *', 'SELECT auto_calculate_salaries()');
8.3 Очистка и обслуживание
8.3.1 Очистка истекших токенов и сессий
sql
CREATE OR REPLACE FUNCTION cleanup_expired_data()
RETURNS void AS $$
BEGIN
  -- Удаление истекших токенов показа карт
  DELETE FROM card_reveal_tokens 
  WHERE expires_at < NOW() - INTERVAL '1 hour';
  
  -- Удаление использованных токенов сброса пароля
  DELETE FROM password_resets 
  WHERE (used = TRUE AND created_at < NOW() - INTERVAL '1 day')
    OR expires_at < NOW() - INTERVAL '7 days';
  
  -- Закрытие истекших сессий
  UPDATE user_sessions 
  SET is_active = FALSE, terminated_reason = 'expired'
  WHERE is_active = TRUE AND expires_at < NOW();
  
  -- Удаление старых неактивных сессий
  DELETE FROM user_sessions 
  WHERE is_active = FALSE 
    AND created_at < NOW() - INTERVAL '30 days';
  
  -- Очистка старых idempotency ключей
  DELETE FROM idempotency_keys 
  WHERE expires_at < NOW();
  
  -- Очистка старых уведомлений
  DELETE FROM notifications
  WHERE read_status = TRUE
    AND created_at < NOW() - INTERVAL '90 days';
END;
$$ LANGUAGE plpgsql;

-- Запуск каждые 10 минут
SELECT cron.schedule('cleanup-expired', '*/10 * * * *', 'SELECT cleanup_expired_data()');
8.3.2 Ротация логов
sql
CREATE OR REPLACE FUNCTION rotate_audit_logs()
RETURNS void AS $$
DECLARE
  v_archive_date DATE := CURRENT_DATE - INTERVAL '6 months';
BEGIN
  -- Перемещение старых логов в архивную таблицу
  INSERT INTO audit_log_archive
  SELECT * FROM audit_log
  WHERE created_at < v_archive_date;
  
  -- Удаление перемещенных записей
  DELETE FROM audit_log
  WHERE created_at < v_archive_date;
  
  -- Аналогично для access_attempts
  INSERT INTO access_attempts_archive
  SELECT * FROM access_attempts
  WHERE created_at < v_archive_date;
  
  DELETE FROM access_attempts
  WHERE created_at < v_archive_date;
  
  -- VACUUM для освобождения места
  VACUUM ANALYZE audit_log;
  VACUUM ANALYZE access_attempts;
END;
$$ LANGUAGE plpgsql;

-- Запуск раз в неделю
SELECT cron.schedule('rotate-logs', '0 3 * * 0', 'SELECT rotate_audit_logs()');
8.4 Мониторинг и алерты
8.4.1 Проверка аномальной активности
sql
CREATE OR REPLACE FUNCTION detect_anomalies()
RETURNS void AS $$
DECLARE
  v_anomaly RECORD;
BEGIN
  -- Обнаружение множественных failed попыток входа
  FOR v_anomaly IN
    SELECT user_id, COUNT(*) as attempts
    FROM access_attempts
    WHERE granted = FALSE
      AND created_at > NOW() - INTERVAL '1 hour'
    GROUP BY user_id
    HAVING COUNT(*) > 5
  LOOP
    INSERT INTO alerts(type, severity, title, description)
    VALUES ('security', 'high', 'Подозрительная активность',
            'Пользователь ' || v_anomaly.user_id || 
            ' - множественные неудачные попытки входа');
  END LOOP;
  
  -- Обнаружение аномального количества депозитов
  FOR v_anomaly IN
    SELECT junior_id, COUNT(*) as deposit_count
    FROM works
    WHERE work_date = CURRENT_DATE
    GROUP BY junior_id
    HAVING COUNT(*) > 20
  LOOP
    INSERT INTO alerts(type, severity, title, description)
    VALUES ('operational', 'medium', 'Аномальная активность',
            'Junior ' || v_anomaly.junior_id || 
            ' создал ' || v_anomaly.deposit_count || ' депозитов за день');
  END LOOP;
  
  -- Проверка карт с множественными активными работами
  FOR v_anomaly IN
    SELECT card_id, COUNT(*) as active_works
    FROM works
    WHERE status = 'active'
    GROUP BY card_id
    HAVING COUNT(*) > 10
  LOOP
    INSERT INTO alerts(type, severity, title, description)
    VALUES ('risk', 'critical', 'Перегруженная карта',
            'Карта ' || v_anomaly.card_id || 
            ' используется в ' || v_anomaly.active_works || ' активных работах');
  END LOOP;
END;
$$ LANGUAGE plpgsql;

-- Запуск каждые 30 минут
SELECT cron.schedule('detect-anomalies', '*/30 * * * *', 'SELECT detect_anomalies()');
8.4.2 Мониторинг системных метрик
sql
CREATE OR REPLACE FUNCTION monitor_system_health()
RETURNS void AS $$
DECLARE
  v_metric RECORD;
BEGIN
  -- Проверка размера таблиц
  FOR v_metric IN
    SELECT 
      schemaname,
      tablename,
      pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size,
      pg_total_relation_size(schemaname||'.'||tablename) as size_bytes
    FROM pg_tables
    WHERE schemaname = 'public'
      AND pg_total_relation_size(schemaname||'.'||tablename) > 1073741824 -- 1GB
  LOOP
    INSERT INTO system_metrics(metric_type, metric_name, value, unit)
    VALUES ('table_size', v_metric.tablename, v_metric.size_bytes, 'bytes');
  END LOOP;
  
  -- Проверка длинных транзакций
  INSERT INTO system_metrics(metric_type, metric_name, value)
  SELECT 'long_transaction', 'count', COUNT(*)
  FROM pg_stat_activity
  WHERE state != 'idle' 
    AND query_start < NOW() - INTERVAL '5 minutes';
  
  -- Проверка очереди уведомлений
  INSERT INTO system_metrics(metric_type, metric_name, value)
  SELECT 'notification_queue', 'pending', COUNT(*)
  FROM notifications
  WHERE push_sent = FALSE
    AND created_at < NOW() - INTERVAL '10 minutes';
END;
$$ LANGUAGE plpgsql;

-- Запуск каждые 5 минут
SELECT cron.schedule('monitor-health', '*/5 * * * *', 'SELECT monitor_system_health()');
8.5 Автоматическое резервное копирование
8.5.1 Создание резервных копий
sql
CREATE OR REPLACE FUNCTION auto_backup()
RETURNS void AS $$
DECLARE
  v_backup_id UUID;
BEGIN
  -- Создание записи о backup
  INSERT INTO backup_history(backup_type, status)
  VALUES ('automated', 'started')
  RETURNING id INTO v_backup_id;
  
  -- Выполнение backup через pg_dump (вызывается внешним скриптом)
  PERFORM pg_notify('backup_channel', 
    json_build_object(
      'backup_id', v_backup_id,
      'type', 'automated'
    )::text
  );
  
  -- Проверка старых backup для удаления (хранить только 30 дней)
  DELETE FROM backup_history
  WHERE backup_type = 'automated'
    AND created_at < NOW() - INTERVAL '30 days'
    AND status = 'completed';
END;
$$ LANGUAGE plpgsql;

-- Ежедневный backup в 3:00 UTC
SELECT cron.schedule('auto-backup', '0 3 * * *', 'SELECT auto_backup()');
8.6 Автоматические уведомления
8.6.1 Push уведомления через WebSocket
sql
-- Триггер отправки push при создании уведомления
CREATE OR REPLACE FUNCTION send_push_notification()
RETURNS TRIGGER AS $$
BEGIN
  -- Публикация в персональный канал пользователя
  PERFORM pg_notify(
    'notifications_' || NEW.user_id::text,
    json_build_object(
      'id', NEW.id,
      'type', NEW.type,
      'title', NEW.title,
      'message', NEW.message,
      'priority', NEW.priority,
      'action_url', NEW.action_url
    )::text
  );
  
  -- Обновление статуса отправки
  NEW.push_sent := TRUE;
  NEW.push_sent_at := NOW();
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_send_push
AFTER INSERT ON notifications
FOR EACH ROW EXECUTE FUNCTION send_push_notification();
8.6.2 Напоминания о задачах
sql
CREATE OR REPLACE FUNCTION send_task_reminders()
RETURNS void AS $$
BEGIN
  -- Напоминания о приближающихся дедлайнах
  INSERT INTO notifications(user_id, type, title, message, priority)
  SELECT 
    ta.user_id,
    'task',
    'Приближается дедлайн',
    'Задача "' || t.title || '" должна быть выполнена через 1 час',
    'high'
  FROM tasks t
  JOIN task_assignees ta ON ta.task_id = t.id
  WHERE t.deadline BETWEEN NOW() + INTERVAL '55 minutes' 
                      AND NOW() + INTERVAL '65 minutes'
    AND t.status NOT IN ('done', 'cancelled')
    AND NOT EXISTS (
      SELECT 1 FROM notifications n
      WHERE n.related_entity_id = t.id
        AND n.type = 'task'
        AND n.created_at > NOW() - INTERVAL '1 day'
    );
END;
$$ LANGUAGE plpgsql;

-- Запуск каждый час
SELECT cron.schedule('task-reminders', '0 * * * *', 'SELECT send_task_reminders()');
Все системные процессы работают автономно, обеспечивая непрерывность бизнес-процессов, своевременное обнаружение проблем и автоматическую обработку рутинных операций без участия пользователей.

